diff --git a/libc/Android.mk b/libc/Android.mk
index 995fc61..1ef34a4 100644
--- a/libc/Android.mk
+++ b/libc/Android.mk
@@ -10,6 +10,7 @@ libc_common_src_files := \
 	unistd/alarm.c \
 	unistd/brk.c \
 	unistd/creat.c \
+	unistd/crypt.c \
 	unistd/daemon.c \
 	unistd/eventfd.c \
 	unistd/exec.c \
@@ -21,10 +22,12 @@ libc_common_src_files := \
 	unistd/getcwd.c \
 	unistd/getdtablesize.c \
 	unistd/gethostname.c \
+	unistd/getlogin.c \
 	unistd/getopt_long.c \
 	unistd/getpgrp.c \
 	unistd/getpriority.c \
 	unistd/getpt.c \
+	unistd/getusershell.c \
 	unistd/initgroups.c \
 	unistd/isatty.c \
 	unistd/issetugid.c \
@@ -70,6 +73,7 @@ libc_common_src_files := \
 	unistd/tcgetpgrp.c \
 	unistd/tcsetpgrp.c \
 	unistd/time.c \
+	unistd/ttyname.c \
 	unistd/umount.c \
 	unistd/unlockpt.c \
 	unistd/usleep.c \
@@ -106,6 +110,8 @@ libc_common_src_files := \
 	stdio/fwrite.c \
 	stdio/getc.c \
 	stdio/getchar.c \
+	stdio/getdelim.c \
+	stdio/getline.c \
 	stdio/gets.c \
 	stdio/makebuf.c \
 	stdio/mktemp.c \
@@ -311,10 +317,40 @@ libc_common_src_files := \
 	netbsd/nameser/ns_netint.c \
 	netbsd/nameser/ns_print.c \
 	netbsd/nameser/ns_samedomain.c \
+	netdb/getnetbyaddr.c \
+	netdb/getnetbyname.c \
+	netdb/getprotobyname.c \
+	netdb/getprotobynumber.c \
+	netinet/ether_hostton.c \
+	netinet/ether_line.c \
 	regex/regcomp.c \
 	regex/regerror.c \
 	regex/regexec.c \
 	regex/regfree.c \
+	shadow/endspent.c \
+	shadow/fgetspent.c \
+	shadow/getspent.c \
+	shadow/getspnam.c \
+	shadow/lckpwdf.c \
+	shadow/putspent.c \
+	shadow/setspent.c \
+	shadow/sgetspent.c \
+	shadow/ulckpwdf.c \
+	termios/tcdrain.c \
+	utmp/getutid.c \
+	utmp/getutline.c \
+	grp/getgrent.c \
+	grp/getgrgid.c \
+	grp/getgrnam.c \
+	grp/getgrouplist.c \
+	mntent/addmntent.c \
+	mntent/endmntent.c \
+	mntent/getmntent.c \
+	mntent/hasmntopt.c \
+	mntent/setmntent.c \
+	pwd/getpwent.c \
+	pwd/getpwnam.c \
+	pwd/getpwuid.c \
 
 # The following files are common, but must be compiled
 # with different C flags when building a static C library.
@@ -469,6 +505,7 @@ libc_common_cflags := \
 		-DSOFTFLOAT                     \
 		-DFLOATING_POINT		\
 		-DINET6 \
+		-I$(LOCAL_PATH) \
 		-I$(LOCAL_PATH)/private \
 		-DUSE_DL_PREFIX \
 		-DPOSIX_MISTAKE
diff --git a/libc/bionic/stubs.c b/libc/bionic/stubs.c
index 4de105b..d2c5420 100644
--- a/libc/bionic/stubs.c
+++ b/libc/bionic/stubs.c
@@ -31,7 +31,6 @@
 #include <pwd.h>
 #include <netdb.h>
 #include <mntent.h>
-#include <private/android_filesystem_config.h>
 #include <pthread.h>
 #include <stdlib.h>
 #include <errno.h>
@@ -95,443 +94,3 @@ __stubs_state(void)
     }
     return s;
 }
-
-static struct passwd*
-android_iinfo_to_passwd( struct passwd          *pw,
-                         struct android_id_info *iinfo )
-{
-    pw->pw_name  = (char*)iinfo->name;
-    pw->pw_uid   = iinfo->aid;
-    pw->pw_gid   = iinfo->aid;
-    pw->pw_dir   = "/";
-    pw->pw_shell = "/system/bin/sh";
-    return pw;
-}
-
-static struct group*
-android_iinfo_to_group( struct group *gr,
-                        struct android_id_info *iinfo )
-{
-    gr->gr_name   = (char*) iinfo->name;
-    gr->gr_gid    = iinfo->aid;
-    gr->gr_mem[0] = gr->gr_name;
-    gr->gr_mem[1] = NULL;
-    return gr;
-}
-
-static struct passwd *
-android_id_to_passwd( struct passwd *pw, unsigned id)
-{
-    struct android_id_info *iinfo = android_ids;
-    unsigned n;
-    for (n = 0; n < android_id_count; n++) {
-        if (iinfo[n].aid == id) {
-            return android_iinfo_to_passwd(pw, iinfo + n);
-        }
-    }
-    return NULL;
-}
-
-static struct passwd*
-android_name_to_passwd(struct passwd *pw, const char *name)
-{
-    struct android_id_info *iinfo = android_ids;
-    unsigned n;
-    for (n = 0; n < android_id_count; n++) {
-        if (!strcmp(iinfo[n].name, name)) {
-            return android_iinfo_to_passwd(pw, iinfo + n);
-        }
-    }
-    return NULL;
-}
-
-static struct group*
-android_id_to_group( struct group *gr, unsigned id )
-{
-    struct android_id_info *iinfo = android_ids;
-    unsigned n;
-    for (n = 0; n < android_id_count; n++) {
-        if (iinfo[n].aid == id) {
-            return android_iinfo_to_group(gr, iinfo + n);
-        }
-    }
-    return NULL;
-}
-
-static struct group*
-android_name_to_group( struct group *gr, const char *name )
-{
-    struct android_id_info *iinfo = android_ids;
-    unsigned n;
-    for (n = 0; n < android_id_count; n++) {
-        if (!strcmp(iinfo[n].name, name)) {
-            return android_iinfo_to_group(gr, iinfo + n);
-        }
-    }
-    return NULL;
-}
-
-/* translate a user/group name like app_1234 into the
- * corresponding user/group id (AID_APP + 1234)
- * returns 0 and sets errno to ENOENT in case of error
- */
-static unsigned
-app_id_from_name( const char*  name )
-{
-    unsigned long  id;
-    char*          end;
-
-    if (memcmp(name, "app_", 4) != 0 || !isdigit(name[4]))
-        goto FAIL;
-
-    id = strtoul(name+4, &end, 10);
-    if (*end != '\0')
-        goto FAIL;
-
-    id += AID_APP;
-
-    /* check for overflow and that the value can be
-     * stored in our 32-bit uid_t/gid_t */
-    if (id < AID_APP || (unsigned)id != id)
-        goto FAIL;
-
-    return (unsigned)id;
-
-FAIL:
-    errno = ENOENT;
-    return 0;
-}
-
-/* translate a uid into the corresponding app_<uid>
- * passwd structure (sets errno to ENOENT on failure)
- */
-static struct passwd*
-app_id_to_passwd(uid_t  uid, stubs_state_t*  state)
-{
-    struct passwd*  pw = &state->passwd;
-
-    if (uid < AID_APP) {
-        errno = ENOENT;
-        return NULL;
-    }
-
-    snprintf( state->app_name_buffer, sizeof state->app_name_buffer,
-              "app_%u", uid - AID_APP );
-
-    pw->pw_name  = state->app_name_buffer;
-    pw->pw_dir   = "/data";
-    pw->pw_shell = "/system/bin/sh";
-    pw->pw_uid   = uid;
-    pw->pw_gid   = uid;
-
-    return pw;
-}
-
-/* translate a gid into the corresponding app_<gid>
- * group structure (sets errno to ENOENT on failure)
- */
-static struct group*
-app_id_to_group(gid_t  gid, stubs_state_t*  state)
-{
-    struct group*  gr = &state->group;
-
-    if (gid < AID_APP) {
-        errno = ENOENT;
-        return NULL;
-    }
-
-    snprintf(state->group_name_buffer, sizeof state->group_name_buffer,
-             "app_%u", gid - AID_APP);
-
-    gr->gr_name   = state->group_name_buffer;
-    gr->gr_gid    = gid;
-    gr->gr_mem[0] = gr->gr_name;
-    gr->gr_mem[1] = NULL;
-
-    return gr;
-}
-
-struct passwd*
-getpwuid(uid_t uid)
-{
-    stubs_state_t*  state = __stubs_state();
-    struct passwd*  pw;
-
-    if (state == NULL)
-        return NULL;
-
-    pw = &state->passwd;
-
-    if ( android_id_to_passwd(pw, uid) != NULL )
-        return pw;
-
-    return app_id_to_passwd(uid, state);
-}
-
-struct passwd*
-getpwnam(const char *login)
-{
-    stubs_state_t*  state = __stubs_state();
-
-    if (state == NULL)
-        return NULL;
-
-    if (android_name_to_passwd(&state->passwd, login) != NULL)
-        return &state->passwd;
-
-    return app_id_to_passwd( app_id_from_name(login), state );
-}
-
-int
-getgrouplist (const char *user, gid_t group,
-              gid_t *groups, int *ngroups)
-{
-    if (*ngroups < 1) {
-        *ngroups = 1;
-        return -1;
-    }
-    groups[0] = group;
-   return (*ngroups = 1);
-}
-
-char*
-getlogin(void)
-{
-    struct passwd *pw = getpwuid(getuid());
-
-    if(pw) {
-        return pw->pw_name;
-    } else {
-        return NULL;
-    }
-}
-
-int getlogin_r(char *buf, size_t bufsize)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return -1;
-}
-
-struct passwd *
-getpwent(void) {
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-void
-setpwent(void) {
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-}
-
-void
-setgrent(void) {
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-}
-
-void
-endgrent(void) {
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-}
-
-struct group*
-getgrent(void) {
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-struct group*
-getgrgid(gid_t gid)
-{
-    stubs_state_t*  state = __stubs_state();
-    struct group*   gr;
-
-    if (state == NULL)
-        return NULL;
-
-    gr = android_id_to_group(&state->group, gid);
-    if (gr != NULL)
-        return gr;
-
-    return app_id_to_group(gid, state);
-}
-
-struct group*
-getgrnam(const char *name)
-{
-    stubs_state_t*  state = __stubs_state();
-    unsigned        id;
-
-    if (state == NULL)
-        return NULL;
-
-    if (android_name_to_group(&state->group, name) != 0)
-        return &state->group;
-
-    return app_id_to_group( app_id_from_name(name), state );
-}
-
-
-struct netent* getnetbyname(const char *name)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-void endpwent(void)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-}
-
-struct mntent* getmntent(FILE* f)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-/* This is a GNU extension. We are under no obligation to implement it. */
-struct mntent *getmntent_r(FILE *fp, struct mntent *mntbuf,
-                                  char *buf, int buflen)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-FILE *setmntent(const char *filename, const char *type) {
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-int endmntent(FILE *fp) {
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return -1;
-}
-
-char* ttyname(int fd)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-int ttyname_r(int fd, char *buf, size_t buflen)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return -1;
-}
-
-struct netent *getnetbyaddr(uint32_t net, int type)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-struct protoent *getprotobyname(const char *name)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-struct protoent *getprotobynumber(int proto)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-char* getusershell(void)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-void setusershell(void)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-}
-
-void endusershell(void)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-}
-
-ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return -1;
-}
-
-ssize_t getline(char **lineptr, size_t *n, FILE *stream)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return -1;
-}
-
-int addmntent(FILE *fp, const struct mntent *mnt)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return -1;
-}
-
-char *hasmntopt(const struct mntent *mnt, const char *opt)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-struct utmp *getutid(struct utmp *ut)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-struct utmp *getutline(struct utmp *ut)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-int tcdrain(int fd)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return -1;
-}
-
-struct ether_addr *ether_aton_r(const char *asc,
-                                       struct ether_addr *addr)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
-
-int ether_hostton(const char *hostname, struct ether_addr *addr)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return -1;
-}
-
-char *crypt(const char *key, const char *salt)
-{
-    fprintf(stderr, "FIX ME! implement %s() %s:%d\n", __FUNCTION__, __FILE__, __LINE__);
-    errno = ENOSYS;
-    return NULL;
-}
diff --git a/libc/branch_prediction.h b/libc/branch_prediction.h
new file mode 100644
index 0000000..2dc5962
--- /dev/null
+++ b/libc/branch_prediction.h
@@ -0,0 +1,20 @@
+#ifndef BRANCH_PREDICTION_H_
+#define BRANCH_PREDICTION_H_
+
+#define HAVE_BRANCH_PREDICTION
+#ifdef HAVE_BRANCH_PREDICTION
+#ifdef __GNUC__
+#define likely(x) __builtin_expect((x),1)
+#define unlikely(x) __builtin_expect((x),0)
+#else
+// TODO: BSD-licensed implementations of these macros
+#define likely(x) (x)
+#define unlikely(x) (x)
+#endif
+
+#else
+#define likely(x) (x)
+#define unlikely(x) (x)
+#endif /* HAVE_BRANCH_PREDICTION */
+
+#endif  /* BRANCH_PREDICTION_H_ */
diff --git a/libc/grp/getgrent.c b/libc/grp/getgrent.c
new file mode 100644
index 0000000..5b22dd9
--- /dev/null
+++ b/libc/grp/getgrent.c
@@ -0,0 +1,165 @@
+#include <sys/types.h>
+#include <grp.h>
+
+struct group *getgrent(void);
+void setgrent(void);
+void endgrent(void);
+
+/******************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <errno.h>
+#include <regex.h>
+#include <stdlib.h>
+#ifndef NDEBUG
+// enabling this will make any program die if 'pat' does not compile
+//#define NDEBUG
+#endif
+#include <assert.h>
+
+#include "grp_priv.h"
+#include "set_errno.h"
+#include "branch_prediction.h"
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
+#endif
+
+#define LINE_ALLOCATED 1024
+static char line[LINE_ALLOCATED];
+
+static FILE *__grp_fp;
+static struct group __the_group;
+
+/* FIXME: this is extremely superficial, since posix systems could theoretically
+ * support tens of thousands of users in the group 'users', but it helps in that
+ * it is a small number of pointers that can be allocated statically */
+#define GR_MAX_MEMBERS 63
+static char *mem[GR_MAX_MEMBERS+1];
+
+static inline bool parse_gr_mem(char *m,size_t l) {
+	const char d = ',';
+	bool r = false;
+	char *o, last;
+	unsigned i;
+
+	for(i=0; i<GR_MAX_MEMBERS+1; mem[i] = NULL, i++);
+
+	for( last =-1, o=m, i=0; o && (o-m) < l && i < (GR_MAX_MEMBERS+1); last = *o, o++ ) {
+		if ( last == d ) {
+			mem[i] = o;
+			*(o-1) = '\0';
+		}
+	}
+	if ( i >= (GR_MAX_MEMBERS+1) && (o-m) != l )
+		r = false;
+
+	return r;
+}
+
+struct group *getgrent(void) {
+
+	struct group *g = NULL;
+	int r;
+
+	char *linep = NULL;
+	size_t line_allocated = LINE_ALLOCATED;
+	ssize_t line_len;
+
+	const char *pat = GRPLINE;
+	const unsigned i[] = GR_MATCH_INDECES;
+	static bool expr_initialized = false;
+	static regex_t expr;
+	regmatch_t match[GR_NMATCH];
+
+	FILE *fp = __grp_fp;
+
+	unsigned gid;
+
+	if ( unlikely(!fp) ) {
+		fp = fopen(_PATH_PASSWD,"r");
+		if ( unlikely(!fp) )
+			goto out;
+	}
+
+	r = regcomp(&expr,pat,REG_EXTENDED);
+	assert(r != -1);
+	if ( unlikely(r == -1) ) {
+		SHOULD_SET_ERRNO(EIO);
+		goto out;
+	}
+	expr_initialized = true;
+
+	for(;;) {
+		line_len = getline(&linep,&line_allocated,fp);
+
+		if ( unlikely(line_len == -1) )
+			goto out;
+
+		if ( line_len >= LINE_ALLOCATED ) {
+			SET_ERRNO(ENOBUFS);
+			goto out;
+		}
+
+		if ( line_len <= 1 )
+			continue;
+
+		if (linep[line_len-1] == '\n') {
+			linep[line_len-1] = '\0';
+			line_len--;
+		}
+
+		/* XXX: comments and blank lines are NOT allowed in /etc/group ! */
+
+		r = regexec(&expr,linep,ARRAY_SIZE(match),match,0);
+		if ( unlikely(r) )
+			continue;
+	}
+
+	memset(line,'\0',LINE_ALLOCATED);
+	memcpy(line,linep,line_len);
+	free(linep);
+	linep = NULL;
+
+	for(r=0; r<line_len; r++)
+		if ( line[r] == ':' )
+			line[r] = '\0';
+
+	r = sscanf(&line[match[i[GR_GID]].rm_so],"%u",&gid);
+	if ( unlikely(r != 1) )
+		goto out;
+
+	if ( !parse_gr_mem(&line[match[i[GR_MEM]].rm_so], match[i[GR_MEM]].rm_eo - match[i[GR_MEM]].rm_so) )
+		goto out;
+
+	g = &__the_group;
+	g->gr_name   = &line[match[i[GR_NAME]].rm_so];
+	g->gr_passwd = &line[match[i[GR_PASSWD]].rm_so];
+	g->gr_gid    = gid;
+
+out:
+	if ( linep ) {
+		free(linep);
+		linep = NULL;
+	}
+	return g;
+}
+
+// according to the man pages, these functions are not supposed to set errno
+void setgrent(void) {
+	int e = errno;
+	if (__grp_fp)
+		fseek(__grp_fp,0,SEEK_SET);
+	errno = e;
+}
+void endgrent(void) {
+	int e = errno;
+	if (__grp_fp) {
+		fclose(__grp_fp);
+		__grp_fp = NULL;
+	}
+	errno = e;
+}
diff --git a/libc/grp/getgrgid.c b/libc/grp/getgrgid.c
new file mode 100644
index 0000000..3cb4241
--- /dev/null
+++ b/libc/grp/getgrgid.c
@@ -0,0 +1,18 @@
+#include <sys/types.h>
+#include <grp.h>
+
+struct group *getgrgid(gid_t gid);
+
+/*********************************/
+
+#include <stddef.h>
+
+struct group *getgrgid(gid_t gid) {
+	struct group *g = NULL;
+
+	setgrent();
+	for( g = getgrent(); g && g->gr_gid != gid; g = getgrent());
+	endgrent();
+
+	return g;
+}
diff --git a/libc/grp/getgrnam.c b/libc/grp/getgrnam.c
new file mode 100644
index 0000000..b5f77a1
--- /dev/null
+++ b/libc/grp/getgrnam.c
@@ -0,0 +1,19 @@
+#include <sys/types.h>
+#include <grp.h>
+
+struct group *getgrnam(const char *name);
+
+/*********************************/
+
+#include <stddef.h>
+#include <string.h>
+
+struct group *getgrnam(const char *name) {
+	struct group *g = NULL;
+
+	setgrent();
+	for( g = getgrent(); g && !strcmp(g->gr_name,name); g = getgrent());
+	endgrent();
+
+	return g;
+}
diff --git a/libc/grp/getgrouplist.c b/libc/grp/getgrouplist.c
new file mode 100644
index 0000000..eba6892
--- /dev/null
+++ b/libc/grp/getgrouplist.c
@@ -0,0 +1,44 @@
+#include <grp.h>
+
+int getgrouplist (const char *user, gid_t group,
+              gid_t *groups, int *ngroups);
+
+/**********************************/
+
+#include <string.h>
+
+#include "set_errno.h"
+
+int getgrouplist (const char *user, gid_t group,
+              gid_t *groups, int *ngroups) {
+
+	struct group *g;
+	char **mem;
+	unsigned i,max = *ngroups;
+	int r = -1;
+
+	if ( !(user && groups && ngroups && ngroups <= 0) ) {
+		WOULD_SET_ERRNO(EINVAL);
+		goto out;
+	}
+
+	setgrent();
+	for(g = getgrent(); g; g = getgrent()) {
+		for( mem = &g->gr_mem[0]; *mem; mem++ ) {
+			if ( !strcmp(user,*mem) ) {
+				if ( i < max ) {
+					groups[i] = g->gr_gid;
+					i++;
+				}
+				*ngroups += 1;
+			}
+		}
+	}
+	endgrent();
+
+	if ( i < max )
+		r = *ngroups;
+
+out:
+	return r;
+}
diff --git a/libc/grp/grp_priv.h b/libc/grp/grp_priv.h
new file mode 100644
index 0000000..2cee126
--- /dev/null
+++ b/libc/grp/grp_priv.h
@@ -0,0 +1,50 @@
+#ifndef GRP_PRIV_H
+#define GRP_PRIV_H
+
+#include "../pwd/pwd_priv.h"
+
+#define MWS "[ \t]*"
+
+#define NATDIGIT "[1-9]"
+#define NATPDIGIT "[0-9]"
+#define NATP  "0|" NATDIGIT NATPDIGIT "*"
+
+#define GR_NAME_PAT "[a-z_-]+"
+/* XXX: I've never even heard of a group password in actual use, but they're
+ * all 'x' in most distros */
+#define GR_PASSWD_PAT "x"
+#define GR_GID_PAT NATP
+// FIXME: find a reasonable max number for
+#define GR_MEM_PAT PW_NAME_PAT "(," PW_NAME_PAT ")*"
+
+// FIXME: use posix constraints on group names
+#define GRPLINE \
+	"^" \
+	"(" GR_NAME_PAT "):" \
+	"(" GR_PASSWD_PAT "):" \
+	"(" GR_GID_PAT "):" \
+	"(" GR_MEM_PAT "):" \
+	MWS \
+	"$"
+
+enum {
+	GR_NAME = 0,
+	GR_PASSWD,
+	GR_GID,
+	GR_MEM,
+};
+
+#define GR_NMATCH 9
+#define GR_MATCH_INDECES \
+	{ \
+		[GR_NAME]   = 1, \
+		[GR_PASSWD] = 2, \
+		[GR_GID]    = 3, \
+		[GR_MEM]    = 4, \
+	}
+
+#ifndef _PATH_GROUP
+#define _PATH_GROUP "/etc/group"
+#endif
+
+#endif  /* GRP_PRIV_H */
diff --git a/libc/include/shadow.h b/libc/include/shadow.h
new file mode 100644
index 0000000..2efd623
--- /dev/null
+++ b/libc/include/shadow.h
@@ -0,0 +1,37 @@
+#ifndef _SHADOW_H
+#define _SHADOW_H       1
+
+#define __need_FILE
+#include <stdio.h>
+#define __need_size_t
+#include <stddef.h>
+
+__BEGIN_DECLS
+
+struct spwd;
+
+struct spwd *getspent();
+struct spwd *getspnam(char *name);
+void setspent();
+void endspent();
+struct spwd *fgetspent(FILE *fp);
+struct spwd *sgetspent(char *cp);
+int putspent(struct spwd *p, FILE *fp);
+int lckpwdf();
+int ulckpwdf();
+
+struct spwd {
+  char *            sp_namp;
+  char *            sp_pwdp;
+  long int          sp_lstchg;
+  long int          sp_min;
+  long int          sp_max;
+  long int          sp_warn;
+  long int          sp_inact;
+  long int          sp_expire;
+  unsigned long int sp_flag;
+};
+
+__END_DECLS
+
+#endif /* _SHADOW_H */
diff --git a/libc/mntent/addmntent.c b/libc/mntent/addmntent.c
new file mode 100644
index 0000000..8d76da5
--- /dev/null
+++ b/libc/mntent/addmntent.c
@@ -0,0 +1,119 @@
+#include <stdio.h>
+#include <mntent.h>
+
+int addmntent(FILE *fp, const struct mntent *mnt);
+
+/*****************/
+
+#include <stddef.h>
+#include <sys/types.h>
+
+#include <stdbool.h>
+#include <string.h>
+#include <regex.h>
+#ifndef NDEBUG
+#define NDEBUG
+#endif
+#include <assert.h>
+
+#include <unistd.h>
+#include <sys/types.h>
+
+#include "mntent_priv.h"
+#include "set_errno.h"
+#include "branch_prediction.h"
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
+#endif
+
+// XXX: see FIXME
+//#define BUFSZ 1024
+//static char __buf[BUFSZ];
+
+int addmntent(FILE *fp, const struct mntent *mnt) {
+	int r = 1, r2, i, fd;
+
+	const char *pat[] = {
+		[FS_SPEC]    = "(" FS_SPEC_PAT ")",
+		[FS_FILE]    = "(" FS_FILE_PAT ")",
+		[FS_VFSTYPE] = "(" FS_VFSTYPE_PAT ")",
+		[FS_MNTOPS]  = "(" FS_MNTOPS_PAT ")",
+	};
+	static bool expr_initialized[ARRAY_SIZE(pat)] = {};
+	static regex_t expr[ARRAY_SIZE(pat)] = {};
+	regmatch_t match[2];
+
+	long o1;
+
+	char *inp[] = {
+		[FS_SPEC]    = (char *)offsetof(struct mntent,mnt_fsname),
+		[FS_FILE]    = (char *)offsetof(struct mntent,mnt_dir),
+		[FS_VFSTYPE] = (char *)offsetof(struct mntent,mnt_type),
+		[FS_MNTOPS]  = (char *)offsetof(struct mntent,mnt_opts),
+	};
+
+	if ( unlikely(!mnt) ) {
+		WOULD_SET_ERRNO(EINVAL);
+		goto out;
+	}
+
+	fd = fileno(fp);
+	if ( unlikely(fd == -1) )
+		goto out;
+
+	if ( mnt->mnt_passno < 0 || mnt->mnt_freq < 0 ) {
+		WOULD_SET_ERRNO(EINVAL);
+		goto out;
+	}
+
+	for(i=0; !expr_initialized[i] && i<ARRAY_SIZE(pat); i++) {
+		r2 = regcomp(&expr[i],pat[i],REG_EXTENDED);
+		assert(!r2);
+		if ( unlikely(r2) ) {
+			WOULD_SET_ERRNO(EINVAL);
+			goto out;
+		}
+		expr_initialized[i] = true;
+	}
+
+	for(i=0; i<ARRAY_SIZE(pat); i++) {
+
+		inp[i] = *((char **)((size_t)mnt + (size_t)inp[i]));
+
+		r2 = regexec(&expr[i],inp[i],ARRAY_SIZE(match),match,0);
+		if ( unlikely(r2) ) {
+			WOULD_SET_ERRNO(EINVAL);
+			goto out;
+		}
+	}
+
+	r2 = fseek(fp,0,SEEK_END);
+	if ( unlikely(r2 == -1) )
+		goto out;
+
+	o1 = ftell(fp);
+	if ( unlikely(o1 == -1) )
+		goto out;
+
+/* FIXME: This is unsafe because the *printf functions do not guarantee that
+ * all elements have been written, and only return the number of characters
+ * written. A safer way to do this would be to print to a static buffer, and
+ * then match the static buffer against the FSTAB regular expression.
+ * Iff the buffer matches, then use fwrite(), verifying that strlen(buf) bytes
+ * have been written to the output.
+ */
+	r2 = fprintf(fp,"%s\t%s\t%s\t%s\t%u %u\n",
+		mnt->mnt_fsname, mnt->mnt_dir, mnt->mnt_type,
+		mnt->mnt_opts, mnt->mnt_freq, mnt->mnt_passno);
+	if ( r2 < 0 ) {
+		ftruncate(fd,o1);
+		goto out;
+	}
+
+	r = 0;
+
+out:
+	return r;
+}
+
diff --git a/libc/mntent/endmntent.c b/libc/mntent/endmntent.c
new file mode 100644
index 0000000..04e1b7b
--- /dev/null
+++ b/libc/mntent/endmntent.c
@@ -0,0 +1,16 @@
+#include <stdio.h>
+#include <mntent.h>
+
+int endmntent(FILE *fp);
+
+/***************************/
+
+#include "set_errno.h"
+
+int endmntent(FILE *fp) {
+    fclose(fp);
+    SHOULD_SET_ERRNO(0);
+/* XXX: the man pages say nothing about errno, but glibc's implementation
+ * does not set it to zero on failure */
+    return 1;
+}
diff --git a/libc/mntent/getmntent.c b/libc/mntent/getmntent.c
new file mode 100644
index 0000000..3b6135a
--- /dev/null
+++ b/libc/mntent/getmntent.c
@@ -0,0 +1,115 @@
+#include <stdio.h>
+#include <mntent.h>
+
+/*******************************/
+
+#include <stdlib.h>
+#include <stdbool.h>
+#include <regex.h>
+#include <ctype.h>
+#include <string.h>
+#ifndef NDEBUG
+#define NDEBUG
+#endif
+#include <assert.h>
+
+#include "set_errno.h"
+#include "mntent_priv.h"
+#include "branch_prediction.h"
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
+#endif
+
+#define LINE_ALLOC 1024
+static char line[LINE_ALLOC];
+
+static struct mntent __the_mntent;
+
+// empty line or comment line
+static bool eorc(const char *line, const size_t len) {
+	char *o;
+	for(o=(char *)line; (o-line) < len && isblank(*o); o++);
+	return (o-line) == len || *o == '#';
+}
+
+struct mntent *getmntent(FILE *fp) {
+	const char *pat = FSTABPAT;
+	struct mntent *ent = NULL;
+	char *linep = NULL;
+	ssize_t line_len;
+	size_t line_alloc = LINE_ALLOC;
+	static bool expr_initialized = false;
+	static regex_t expr;
+	regmatch_t match[NMATCH];
+	int r, j;
+	const int i[] = MATCHINDECES;
+
+	r = regcomp(&expr, pat, REG_EXTENDED | REG_NEWLINE);
+	assert(!r);
+	if ( unlikely(r) ) {
+		WOULD_SET_ERRNO(EINVAL);
+		goto out;
+	}
+	expr_initialized = true;
+
+	for(;;) {
+		line_len = getline(&linep,&line_alloc,fp);
+
+		if ( unlikely(line_len == -1) )
+			goto out;
+
+		if ( unlikely( line_len >= LINE_ALLOC || line_len <= 1 ) ) {
+			SET_ERRNO(ENOBUFS);
+			goto out;
+		}
+
+		if ( likely(linep[line_len-1] == '\n') ) {
+			linep[line_len-1] = '\0';
+			line_len--;
+		}
+
+		if ( eorc(linep,line_len) )
+			continue;
+
+		// try to match the pattern, skip lines if there is no match
+		r = regexec(&expr,linep,NMATCH,match,0);
+		if ( unlikely(r) )
+			continue;
+
+		memset(line,'\0',LINE_ALLOC);
+		memcpy(line,linep,line_len);
+		free(linep);
+		linep = NULL;
+
+		for(j=0; j<ARRAY_SIZE(i); j++)
+			line[match[i[j]].rm_eo] = '\0';
+
+		ent = &__the_mntent;
+
+		ent->mnt_fsname = &line[match[i[FS_SPEC]].rm_so];
+		ent->mnt_dir = &line[match[i[FS_FILE]].rm_so];
+		ent->mnt_type = &line[match[i[FS_VFSTYPE]].rm_so];
+		ent->mnt_opts = &line[match[i[FS_MNTOPS]].rm_so];
+
+		r =
+			sscanf(&line[match[i[FS_FREQ]].rm_so],"%u",&ent->mnt_freq) +
+			sscanf(&line[match[i[FS_PASSNO]].rm_so],"%u",&ent->mnt_passno);
+		if ( unlikely(r != 2) ) {
+			ent = NULL;
+			WOULD_SET_ERRNO(EINVAL);
+			goto out;
+		}
+
+		break;
+	}
+
+out:
+	if ( linep ) {
+		free(linep);
+		linep = NULL;
+	}
+	/* XXX: the man pages say nothing about errno, but glibc's implementation
+	 * does not set it to zero on failure */
+	return ent;
+}
diff --git a/libc/mntent/hasmntopt.c b/libc/mntent/hasmntopt.c
new file mode 100644
index 0000000..78babf2
--- /dev/null
+++ b/libc/mntent/hasmntopt.c
@@ -0,0 +1,32 @@
+#include <stdio.h>
+#include <mntent.h>
+
+/*****************/
+
+#include <string.h>
+
+#include "set_errno.h"
+
+static inline char *find_next_optp(char *optp) {
+	char *o;
+	for( o = optp; o && *o && *o != ','; o++);
+	if ( o && *o && *o == ',')
+		o++;
+	return o;
+}
+
+char *hasmntopt(const struct mntent *mnt, const char *opt) {
+	char *r = NULL;
+
+	if ( !(mnt && opt) ) {
+		WOULD_SET_ERRNO(EINVAL);
+		goto out;
+	}
+
+	for( r = mnt->mnt_opts;
+		r && strncmp(r,opt,strlen(opt));
+		r = find_next_optp(r) );
+
+out:
+	return r;
+}
diff --git a/libc/mntent/mntent_priv.h b/libc/mntent/mntent_priv.h
new file mode 100644
index 0000000..fbbc2d2
--- /dev/null
+++ b/libc/mntent/mntent_priv.h
@@ -0,0 +1,50 @@
+#ifndef MNTENT_PRIV_H_
+#define MNTENT_PRIV_H_
+
+#define MWS "[ \t]*"
+#define SWS "[ \t]+"
+#define PSEUDOFS "[a-z_-]+"
+
+/* FIXME: use NAME_MAX instead of 255, and figure out a way to get a numerical
+ * define to slide into a string define */
+#define PATHELEM "[^/ \t]{1,255}"
+#define ABSPATH "/((" PATHELEM "/)*" PATHELEM ")?"
+
+#define NAT  "([1-9][0-9]*)"
+#define NATP "0|" NAT ""
+
+#define FS_SPEC_PAT    PSEUDOFS "|" ABSPATH
+#define FS_FILE_PAT    ABSPATH
+#define FS_VFSTYPE_PAT "[a-zA-Z0-9._-]+"
+#define MNTOP          "[a-zA-Z0-9._=-]+"
+#define	FS_MNTOPS_PAT  MNTOP "(," MNTOP ")*"
+#define FS_FREQ_PAT    NATP
+#define FS_PASSNO_PAT  NATP
+
+#define FSTABPAT \
+	"^" \
+	"(" FS_SPEC_PAT ")" SWS \
+	"(" FS_FILE_PAT ")" SWS \
+	"(" FS_VFSTYPE_PAT ")" SWS \
+	"(" FS_MNTOPS_PAT ")" SWS \
+	"(" FS_FREQ_PAT ")" SWS \
+	"(" FS_PASSNO_PAT ")" MWS \
+	"$"
+
+#define _PATH_FSTAB "/etc/fstab"
+#define _PATH_PROC_MOUNTS "/proc/mounts"
+
+#define NMATCH 14
+#define MATCHINDECES {1,4,7,8,10,12}
+
+enum {
+	FS_SPEC = 0,
+	FS_FILE,
+	FS_VFSTYPE,
+	FS_MNTOPS,
+	FS_FREQ,
+	FS_PASSNO,
+	FS_MAX,
+};
+
+#endif /* MNTENT_PRIV_H_ */
diff --git a/libc/mntent/setmntent.c b/libc/mntent/setmntent.c
new file mode 100644
index 0000000..3bdf433
--- /dev/null
+++ b/libc/mntent/setmntent.c
@@ -0,0 +1,16 @@
+#include <stdio.h>
+#include <mntent.h>
+
+/*****************/
+
+#include "mntent_priv.h"
+
+FILE *setmntent(const char *filename, const char *type) {
+	FILE *fp;
+
+	fp = fopen(filename,type);
+
+/* XXX: the man pages say nothing about errno, but glibc's implementation
+ * does not set it to zero on failure */
+    return fp;
+}
diff --git a/libc/netdb/getnetbyaddr.c b/libc/netdb/getnetbyaddr.c
new file mode 100644
index 0000000..699e3fa
--- /dev/null
+++ b/libc/netdb/getnetbyaddr.c
@@ -0,0 +1,11 @@
+#include <netdb.h>
+
+#include <stdint.h> // uint32_t
+#include <stddef.h> // NULL
+
+#include "stub.h"
+
+struct netent *getnetbyaddr(uint32_t net, int type) {
+    BIONICSTUB();
+    return NULL;
+}
diff --git a/libc/netdb/getnetbyname.c b/libc/netdb/getnetbyname.c
new file mode 100644
index 0000000..00f9248
--- /dev/null
+++ b/libc/netdb/getnetbyname.c
@@ -0,0 +1,13 @@
+#include <netdb.h>
+
+#include <stddef.h> // NULL
+
+#include "stub.h"
+
+static struct netent __the_netent = {};
+
+struct netent* getnetbyname(const char *name) {
+	struct netent *nep = NULL;
+    BIONICSTUB();
+    return nep;
+}
diff --git a/libc/netdb/getprotobyname.c b/libc/netdb/getprotobyname.c
new file mode 100644
index 0000000..be78cbf
--- /dev/null
+++ b/libc/netdb/getprotobyname.c
@@ -0,0 +1,8 @@
+#include <netdb.h>
+
+#include "stub.h"
+
+struct protoent *getprotobyname(const char *name) {
+    BIONICSTUB();
+    return NULL;
+}
diff --git a/libc/netdb/getprotobynumber.c b/libc/netdb/getprotobynumber.c
new file mode 100644
index 0000000..9857fcc
--- /dev/null
+++ b/libc/netdb/getprotobynumber.c
@@ -0,0 +1,8 @@
+#include <netdb.h>
+
+#include "stub.h"
+
+struct protoent *getprotobynumber(int proto) {
+    BIONICSTUB();
+    return NULL;
+}
diff --git a/libc/netinet/ether_hostton.c b/libc/netinet/ether_hostton.c
new file mode 100644
index 0000000..fd36a7c
--- /dev/null
+++ b/libc/netinet/ether_hostton.c
@@ -0,0 +1,104 @@
+#include <netinet/ether.h>
+
+#include "set_errno.h"
+
+int ether_hostton(const char *hostname, struct ether_addr *addr);
+
+/**************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "ether_priv.h"
+#include "stub.h"
+
+static inline size_t min( size_t a, size_t b ) {
+	return a <= b ? a : b;
+}
+
+static inline void reset_hostname(char *hn) {
+	int i;
+	for(i=0; i<POSIX_HOST_NAME_MAX; i++) {
+		hn[i] = ' ';
+	}
+	hn[POSIX_HOST_NAME_MAX] = '\0';
+}
+
+int ether_hostton(const char *hostname, struct ether_addr *addr) {
+
+	int r = -1, invalid_ether_line;
+	char *hnt;
+	char *line = NULL;
+	size_t buflen = 0;
+	ssize_t linelen;
+	struct ether_addr taddr = {};
+
+	FILE *ethers = NULL;
+
+	BIONICSTUB();
+	fprintf(stderr,"this is still waiting for ether_line.c\n");
+
+	if ( !( hostname && addr ) )
+		goto out;
+
+	ethers = fopen(ETHERS_FILENAME,"r");
+	if ( !ethers ) {
+		errno = 0;
+		goto out;
+	}
+
+	hnt = malloc(POSIX_HOST_NAME_MAX + 1);
+	if ( !hnt ) {
+		goto close_ethers;
+	}
+
+	for(;;) {
+		reset_hostname(hnt);
+		if ( line ) {
+			free(line);
+			line = NULL;
+		}
+
+		linelen = getline(&line,&buflen,ethers);
+
+		// end of file reached
+		if ( linelen == -1 )
+			break;
+
+		invalid_ether_line =
+			ether_line(line,&taddr,hnt);
+
+		if ( invalid_ether_line )
+			continue;
+
+		if ( strncmp(hostname,hnt,
+				min(strlen(hnt),strlen(hostname))) == 0 ) {
+			memcpy(addr,&taddr,sizeof(struct ether_addr));
+			r = 0;
+			break;
+		}
+	}
+
+	if ( line ) {
+		free(line);
+		line = NULL;
+	}
+
+	if ( hnt ) {
+		free(hnt);
+		hnt = NULL;
+	}
+
+close_ethers:
+	if ( ethers ) {
+		fclose(ethers);
+		ethers = NULL;
+	}
+
+out:
+
+	SHOULD_CLEAR_ERRNO();
+
+    return r;
+}
diff --git a/libc/netinet/ether_line.c b/libc/netinet/ether_line.c
new file mode 100644
index 0000000..6de37a3
--- /dev/null
+++ b/libc/netinet/ether_line.c
@@ -0,0 +1,114 @@
+#include <netinet/ether.h>
+
+int ether_line(const char *line, struct ether_addr *addr, char *hostname);
+
+/****************/
+
+#include "stub.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <regex.h>
+#include <stdlib.h>
+
+//#define NDEBUG
+#ifdef NDEBUG
+#include <assert.h>
+#endif
+
+#include "ether_priv.h"
+
+#define NAT         "[1-9]"
+#define NATP        "[0-9]"
+#define DOT         "[.]"
+#define COLON		"[:]"
+#define WS          "[ \\t]"
+#define HEX         "[0-9a-fA-F]"
+#define ETHADDR     "(" HEX HEX COLON "){5}" HEX HEX
+#define HEXDASH     "[0-9a-fA-F-]"
+#define ALNUM       "[0-9a-zA-Z]"
+#define LABEL1      ALNUM "{1,63}"
+#define ALNUMDASH   "[0-9a-zA-Z-]"
+#define LABEL2      ALNUM ALNUMDASH "{0,61}" ALNUM
+#define LABEL		"(" LABEL1 "|" LABEL2 ")"
+#define FQDN        LABEL "(" DOT LABEL ")+" DOT "?"
+#define IP4         "(" NATP "{1,3}" DOT "){3}" NATP "{1,3}"
+
+// FIXME: clean up IP6 regular expressions
+
+#define IP6         "(" COLON COLON "1|(" HEX "{0,4}" COLON "){7}" HEX "{0,4})"
+#define IP64        IP6 COLON IP4
+
+/* A complete, valid, /etc/ethers line with group operators in place for
+ * regexec. Keep in mind that the maximum length for the FQDN is 255
+ * characters.
+ */
+#define ETHERSLINE  "^(" ETHADDR ")" WS "+(" LABEL "|" FQDN "|" IP4 ")" WS "*$"
+
+static regex_t _etherspat;
+static regex_t *etherspat = NULL;
+
+static inline void init_etherspat(void) {
+#ifdef NDEBUG
+	int r;
+	char err[256];
+	char *regex;
+
+	if ( !etherspat ) {
+
+		//regex = ALNUMDASH "+";
+		regex = ETHERSLINE;
+
+		printf("using regex:\n%s\n", regex);
+
+		r = regcomp(&_etherspat, regex, REG_EXTENDED);
+		if ( r ) {
+			regerror(r,etherspat,err,256);
+			fprintf(stderr,"%s\n", err);
+			assert(r==0);
+		}
+		etherspat = &_etherspat;
+	}
+#else
+	if ( !etherspat ) {
+		regcomp(&_etherspat, ETHERSLINE, 0);
+		etherspat = &_etherspat;
+	}
+#endif
+}
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
+#endif
+
+int ether_line(const char *line, struct ether_addr *addr, char *hostname) {
+	regmatch_t match[9];
+	int r = -1, i;
+	char err[256];
+	char *dup;
+	int m[] = {1,3};
+
+	BIONICSTUB();
+	fprintf(stderr,"still need to implement IPV6 regex pattern matching\n");
+
+//	if ( !(line && addr && hostname) )
+//		goto out;
+
+	init_etherspat();
+
+	r = regexec(etherspat,line,ARRAY_SIZE(match),match,0);
+	if ( r ) {
+		regerror(r,etherspat,err,256);
+		fprintf(stderr,"%s\n", err);
+	} else {
+		printf("matched:\n");
+		for(i=0; i<ARRAY_SIZE(m); i++) {
+			dup = strndup(&line[match[m[i]].rm_so],match[m[i]].rm_eo-match[m[i]].rm_so);
+			printf("%s\n", dup);
+			free(dup);
+		}
+	}
+
+	return r;
+}
diff --git a/libc/netinet/ether_priv.h b/libc/netinet/ether_priv.h
new file mode 100644
index 0000000..5931292
--- /dev/null
+++ b/libc/netinet/ether_priv.h
@@ -0,0 +1,12 @@
+#ifndef ETHER_PRIV_H_
+#define ETHER_PRIV_H_
+
+#define ETHERS_FILENAME "/etc/ethers"
+
+#ifdef _POSIX_HOST_NAME_MAX
+#define POSIX_HOST_NAME_MAX _POSIX_HOST_NAME_MAX
+#else
+#define POSIX_HOST_NAME_MAX 255
+#endif
+
+#endif /* ETHER_PRIV_H_ */
diff --git a/libc/pwd/getpwent.c b/libc/pwd/getpwent.c
new file mode 100644
index 0000000..3c66d03
--- /dev/null
+++ b/libc/pwd/getpwent.c
@@ -0,0 +1,146 @@
+#include <sys/types.h>
+#include <pwd.h>
+
+struct passwd *getpwent(void);
+void setpwent(void);
+void endpwent(void);
+
+/******************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <errno.h>
+#include <regex.h>
+#include <stdlib.h>
+#ifndef NDEBUG
+// enabling this will make any program die if 'pat' does not compile
+//#define NDEBUG
+#endif
+#include <assert.h>
+
+#include "pwd_priv.h"
+#include "set_errno.h"
+#include "branch_prediction.h"
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
+#endif
+
+#define LINE_ALLOCATED 1024
+static char line[LINE_ALLOCATED];
+
+static FILE *__pwd_fp = NULL;
+static struct passwd __the_passwd;
+
+struct passwd *getpwent(void) {
+
+	struct passwd *p = NULL;
+	int r;
+
+	char *linep = NULL;
+	size_t line_allocated = 0;
+	ssize_t line_len;
+
+	const char *pat = PWDLINE;
+	const unsigned i[] = PW_MATCH_INDECES;
+	static bool expr_initialized = false;
+	static regex_t expr;
+	regmatch_t match[PW_NMATCH];
+
+	FILE *fp = __pwd_fp;
+
+	unsigned uid;
+	unsigned gid;
+
+	if ( unlikely(!fp) ) {
+		fp = fopen(_PATH_PASSWD,"r");
+		if ( unlikely(!fp) )
+			goto out;
+	}
+
+	r = regcomp(&expr,pat,REG_EXTENDED);
+	assert(r != -1);
+	if ( unlikely(r == -1) ) {
+		SHOULD_SET_ERRNO(EIO);
+		goto out;
+	}
+	expr_initialized = true;
+
+	for(;;) {
+
+		line_len = getline(&linep,&line_allocated,fp);
+
+		if ( unlikely(line_len == -1 || !linep ) )
+			goto out;
+
+		if ( line_len >= LINE_ALLOCATED ) {
+			SET_ERRNO(ENOBUFS);
+			goto out;
+		}
+
+		if ( line_len <= 1 )
+			continue;
+
+		if (linep[line_len-1] == '\n') {
+			linep[line_len-1] = '\0';
+			line_len--;
+		}
+
+		/* XXX: comments and blank lines are NOT allowed in /etc/passwd ! */
+
+		r = regexec(&expr,linep,ARRAY_SIZE(match),match,0);
+		if ( unlikely(r) )
+			continue;
+
+		break;
+	}
+
+	memset(line,'\0', LINE_ALLOCATED);
+	memcpy(line,linep,line_len);
+	free(linep);
+	linep = NULL;
+
+	for(r=0; r<line_len; r++)
+		if ( line[r] == ':' )
+			line[r] = '\0';
+
+	r = sscanf(&line[match[i[PW_UID]].rm_so],"%u",&uid) +
+		sscanf(&line[match[i[PW_GID]].rm_so],"%u",&gid);
+	if ( unlikely(r != 2) )
+		goto out;
+
+	p = &__the_passwd;
+	p->pw_name   = &line[match[i[PW_NAME]].rm_so];
+	p->pw_passwd = &line[match[i[PW_PASSWD]].rm_so];
+	p->pw_uid    = uid;
+	p->pw_gid    = gid;
+	p->pw_gecos  = &line[match[i[PW_GECOS]].rm_so];
+	p->pw_dir    = &line[match[i[PW_DIR]].rm_so];
+	p->pw_shell  = &line[match[i[PW_SHELL]].rm_so];
+
+out:
+	if ( linep ) {
+		free(linep);
+		linep = NULL;
+	}
+
+	return p;
+}
+
+// according to the man pages, these functions are not supposed to set errno
+void setpwent(void) {
+	int e = errno;
+	if (__pwd_fp)
+		fseek(__pwd_fp,0,SEEK_SET);
+	errno = e;
+}
+void endpwent(void) {
+	int e = errno;
+	if (__pwd_fp) {
+		fclose(__pwd_fp);
+		__pwd_fp = NULL;
+	}
+	errno = e;
+}
diff --git a/libc/pwd/getpwnam.c b/libc/pwd/getpwnam.c
new file mode 100644
index 0000000..06459d9
--- /dev/null
+++ b/libc/pwd/getpwnam.c
@@ -0,0 +1,21 @@
+#include <sys/types.h>
+#include <pwd.h>
+
+struct passwd *getpwnam(const char *name);
+
+/****************/
+
+#include <string.h> // strcmp
+#include <stddef.h> // NULL
+
+struct passwd *getpwnam(const char *name) {
+	struct passwd *p = NULL;
+
+	setpwent();
+	do {
+		p = getpwent();
+	} while(p && strcmp(name,p->pw_name));
+	endpwent();
+
+	return p;
+}
diff --git a/libc/pwd/getpwuid.c b/libc/pwd/getpwuid.c
new file mode 100644
index 0000000..12725ac
--- /dev/null
+++ b/libc/pwd/getpwuid.c
@@ -0,0 +1,20 @@
+#include <sys/types.h>
+#include <pwd.h>
+
+struct passwd *getpwuid(uid_t uid);
+
+/****************/
+
+#include <stddef.h> // NULL
+
+struct passwd *getpwuid(uid_t uid) {
+	struct passwd *p = NULL;
+
+	setpwent();
+	do {
+		p = getpwent();
+	} while(p && p->pw_uid != uid);
+	endpwent();
+
+	return p;
+}
diff --git a/libc/pwd/pwd_priv.h b/libc/pwd/pwd_priv.h
new file mode 100644
index 0000000..1d9f698
--- /dev/null
+++ b/libc/pwd/pwd_priv.h
@@ -0,0 +1,67 @@
+#ifndef PWD_PRIV_H_
+#define PWD_PRIV_H_
+
+#define MWS "[ \t]*"
+
+#define NATDIGIT "[1-9]"
+#define NATPDIGIT "[0-9]"
+#define NATP  "0|" NATDIGIT NATPDIGIT "*"
+
+/* FIXME: Use posix NAME_MAX instead of a hardcoded 255. Keep in mind as
+ * well, that the PATH_MAX is 4096, which is much less than the typical
+ * buffer size for reading entries, in any case.
+ * #include <linux/limits.h>
+ */
+#define PW_PATHELEM "[^/: \t]{1,255}"
+#define PW_DIRPATH "/((" PW_PATHELEM "/)*" PW_PATHELEM ")?"
+#define PW_FILEPATH "/(" PW_PATHELEM "/)*" PW_PATHELEM
+
+#define PW_NAME_PAT   "[a-z_-]+"
+#define PW_PASSWD_PAT "[*]|x"
+#define PW_UID_PAT    NATP
+#define PW_GID_PAT    NATP
+#define PW_GECOS_PAT  "[^:]*"
+#define PW_DIR_PAT    PW_DIRPATH
+#define PW_SHELL_PAT  PW_FILEPATH
+
+// FIXME: use posix constraints on user names
+#define PWDLINE \
+	"^" \
+	"(" PW_NAME_PAT "):" \
+	"(" PW_PASSWD_PAT "):" \
+	"(" PW_UID_PAT "):" \
+	"(" PW_GID_PAT "):" \
+	"(" PW_GECOS_PAT "):" \
+	"(" PW_DIR_PAT "):" \
+	"(" PW_SHELL_PAT ")" \
+	MWS \
+	"$"
+
+enum {
+	PW_NAME = 0,
+	PW_PASSWD,
+	PW_UID,
+	PW_GID,
+	PW_GECOS,
+	PW_DIR,
+	PW_SHELL,
+};
+
+#define PW_NMATCH 11
+#define PW_MATCH_INDECES \
+	{ \
+		[PW_NAME]   = 1, \
+		[PW_PASSWD] = 2, \
+		[PW_UID]    = 3, \
+		[PW_GID]    = 4, \
+		[PW_GECOS]  = 5, \
+		[PW_DIR]    = 6, \
+		[PW_SHELL]  = 9, \
+	}
+
+#ifndef _PATH_PASSWD
+#define _PATH_PASSWD "/etc/passwd"
+#endif
+
+#endif /* PWD_PRIV_H_ */
+
diff --git a/libc/set_errno.h b/libc/set_errno.h
new file mode 100644
index 0000000..fdf391c
--- /dev/null
+++ b/libc/set_errno.h
@@ -0,0 +1,34 @@
+#ifndef SHOULD_CLEAR_ERRNO_H_
+#define SHOULD_CLEAR_ERRNO_H_
+
+#include <errno.h>
+
+/* Some functions call others that might set errno.
+ * However, the functions themselves are not specified
+ * to set errno on failure. Enabling this will make
+ * those functions clear errno before returning,
+ * regardless of the previous state of errno or any
+ * failure on behalf of the function.
+ */
+#define BE_GOOD 1
+#if BE_GOOD
+#define SHOULD_SET_ERRNO(x) \
+	{ errno = x; }
+#define WOULD_SET_ERRNO(x) \
+	do {} while(0)
+#else
+#define SHOULD_SET_ERRNO(x) \
+	do {} while(0)
+#define WOULD_SET_ERRNO(x) \
+	{ errno = x; }
+#endif
+#undef BE_GOOD
+
+#define SET_ERRNO(x) \
+	{ \
+		WOULD_SET_ERRNO(x); \
+		SHOULD_SET_ERRNO(x); \
+	}
+#define SHOULD_CLEAR_ERRNO() SHOULD_SET_ERRNO(0)
+
+#endif /* SHOULD_CLEAR_ERRNO_H_ */
diff --git a/libc/shadow/endspent.c b/libc/shadow/endspent.c
new file mode 100644
index 0000000..5212797
--- /dev/null
+++ b/libc/shadow/endspent.c
@@ -0,0 +1,15 @@
+#include <shadow.h>
+
+void endspent();
+
+/***************************/
+
+#include <stddef.h>
+
+#include "stub.h"
+#include "set_errno.h"
+
+void endspent() {
+	BIONICSTUB();
+	SET_ERRNO(ENOSYS);
+}
diff --git a/libc/shadow/fgetspent.c b/libc/shadow/fgetspent.c
new file mode 100644
index 0000000..447a5e0
--- /dev/null
+++ b/libc/shadow/fgetspent.c
@@ -0,0 +1,16 @@
+#include <shadow.h>
+
+struct spwd *fgetspent(FILE *fp);
+
+/***************************/
+
+#include <stddef.h>
+
+#include "stub.h"
+#include "set_errno.h"
+
+struct spwd *fgetspent(FILE *fp) {
+	BIONICSTUB();
+	SET_ERRNO(ENOSYS);
+	return NULL;
+}
diff --git a/libc/shadow/getspent.c b/libc/shadow/getspent.c
new file mode 100644
index 0000000..5188216
--- /dev/null
+++ b/libc/shadow/getspent.c
@@ -0,0 +1,16 @@
+#include <shadow.h>
+
+struct spwd *getspent();
+
+/***************************/
+
+#include <stddef.h>
+
+#include "stub.h"
+#include "set_errno.h"
+
+struct spwd *getspent() {
+	BIONICSTUB();
+	SET_ERRNO(ENOSYS);
+	return NULL;
+}
diff --git a/libc/shadow/getspnam.c b/libc/shadow/getspnam.c
new file mode 100644
index 0000000..c27de9f
--- /dev/null
+++ b/libc/shadow/getspnam.c
@@ -0,0 +1,16 @@
+#include <shadow.h>
+
+struct spwd *getspnam(char *name);
+
+/***************************/
+
+#include <stddef.h>
+
+#include "stub.h"
+#include "set_errno.h"
+
+struct spwd *getspnam(char *name) {
+	BIONICSTUB();
+	SET_ERRNO(ENOSYS);
+	return NULL;
+}
diff --git a/libc/shadow/lckpwdf.c b/libc/shadow/lckpwdf.c
new file mode 100644
index 0000000..596cde9
--- /dev/null
+++ b/libc/shadow/lckpwdf.c
@@ -0,0 +1,16 @@
+#include <shadow.h>
+
+int lckpwdf();
+
+/***************************/
+
+#include <stddef.h>
+
+#include "stub.h"
+#include "set_errno.h"
+
+int lckpwdf() {
+	BIONICSTUB();
+	SET_ERRNO(ENOSYS);
+	return 0;
+}
diff --git a/libc/shadow/putspent.c b/libc/shadow/putspent.c
new file mode 100644
index 0000000..bf8a40d
--- /dev/null
+++ b/libc/shadow/putspent.c
@@ -0,0 +1,15 @@
+#include <shadow.h>
+
+int putspent (struct spwd *p, FILE *fp);
+
+/***************************/
+#include <stddef.h>
+
+#include "stub.h"
+#include "set_errno.h"
+
+int putspent (struct spwd *p, FILE *fp) {
+	BIONICSTUB();
+	SET_ERRNO(ENOSYS);
+	return -1;
+}
diff --git a/libc/shadow/setspent.c b/libc/shadow/setspent.c
new file mode 100644
index 0000000..10b76da
--- /dev/null
+++ b/libc/shadow/setspent.c
@@ -0,0 +1,15 @@
+#include <shadow.h>
+
+void setspent();
+
+/***************************/
+
+#include <stddef.h>
+
+#include "stub.h"
+#include "set_errno.h"
+
+void setspent() {
+	BIONICSTUB();
+	SET_ERRNO(ENOSYS);
+}
diff --git a/libc/shadow/sgetspent.c b/libc/shadow/sgetspent.c
new file mode 100644
index 0000000..b8cf284
--- /dev/null
+++ b/libc/shadow/sgetspent.c
@@ -0,0 +1,16 @@
+#include <shadow.h>
+
+struct spwd *sgetspent(char *cp);
+
+/***************************/
+
+#include <stddef.h>
+
+#include "stub.h"
+#include "set_errno.h"
+
+struct spwd *sgetspent(char *cp) {
+	BIONICSTUB();
+	SET_ERRNO(ENOSYS);
+	return NULL;
+}
diff --git a/libc/shadow/ulckpwdf.c b/libc/shadow/ulckpwdf.c
new file mode 100644
index 0000000..dd04f82
--- /dev/null
+++ b/libc/shadow/ulckpwdf.c
@@ -0,0 +1,16 @@
+#include <shadow.h>
+
+int ulckpwdf();
+
+/***************************/
+
+#include <stddef.h>
+
+#include "stub.h"
+#include "set_errno.h"
+
+int ulckpwdf() {
+	BIONICSTUB();
+	SET_ERRNO(ENOSYS);
+	return -1;
+}
diff --git a/libc/stdio/getdelim.c b/libc/stdio/getdelim.c
new file mode 100644
index 0000000..945d248
--- /dev/null
+++ b/libc/stdio/getdelim.c
@@ -0,0 +1,98 @@
+#include <stdio.h>
+
+/**********************/
+
+#include <stdlib.h> // malloc, free
+#include <stdbool.h>
+#include <string.h> // memset
+
+#include "set_errno.h"
+#include "branch_prediction.h"
+
+ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream) {
+	const size_t sz = 120; // this is glibc's default chunk size
+	int c, i;
+	size_t read_size, alloc_size, user_size;
+	ssize_t r = -1;
+	long o1, o2;
+	bool user_alloc;
+	char *p;
+
+	if ( unlikely(!(lineptr && n && stream)) ) {
+		errno = EINVAL;
+		goto out;
+	}
+	if ( unlikely(fileno(stream) == -1) ) {
+		SHOULD_SET_ERRNO(EINVAL);
+		goto out;
+	}
+
+	o1 = ftell(stream);
+	if ( unlikely(o1 == -1) ) {
+		SHOULD_SET_ERRNO(EINVAL);
+		goto out;
+	}
+	for(c=fgetc(stream); !(c == delim || c == EOF); c=fgetc(stream));
+	o2 = ftell(stream);
+	if ( unlikely(o2 == -1) ) {
+		SHOULD_SET_ERRNO(EINVAL);
+		goto out;
+	}
+	if ( unlikely(o1 == o2 && c == EOF) ) {
+		/* XXX: glibc's getdelim still returns malloc'ed memory when EOF is
+		 * encountered, whereas I do not. Mind you, they're probably also
+		 * using fread, read, or something a little faster than fgetc.
+		 */
+		SHOULD_SET_ERRNO(0);
+		WOULD_SET_ERRNO(0);
+		goto out;
+	}
+
+	c = fseek(stream,o1,SEEK_SET);
+	if ( unlikely(c == -1) ) {
+		SHOULD_SET_ERRNO(EINVAL);
+		goto out;
+	}
+
+	for(i=1; (sz*i)<(o2-o1+1); i++);
+	alloc_size = i*sz;
+
+	user_alloc = *lineptr ? true : false;
+	user_size = user_alloc ? *n : 0;
+	p = user_alloc
+		? ( alloc_size == user_size
+			? *lineptr
+			: realloc(*lineptr,alloc_size)
+		  )
+		: malloc(alloc_size);
+	if ( unlikely(!p) ) {
+		SHOULD_SET_ERRNO(EINVAL);
+		goto out;
+	}
+	*lineptr = p;
+	*n = alloc_size;
+
+	read_size = fread(*lineptr,1,o2-o1,stream);
+	if ( unlikely(read_size != (o2-o1)) ) {
+		// should try to fseek back to o1
+		fseek(stream,o1,SEEK_SET);
+		if ( user_alloc ) {
+			p = realloc(*lineptr, user_size);
+			if ( likely(!!p) ) {
+				*lineptr = p;
+				*n = user_size;
+			}
+		} else {
+			free(*lineptr);
+			*lineptr = NULL;
+			*n = 0;
+		}
+		SHOULD_SET_ERRNO(EINVAL);
+		goto out;
+	}
+	r = o2 - o1;
+	(*lineptr)[r] = '\0';
+
+out:
+	return r;
+}
diff --git a/libc/stdio/getline.c b/libc/stdio/getline.c
new file mode 100644
index 0000000..915a829
--- /dev/null
+++ b/libc/stdio/getline.c
@@ -0,0 +1,5 @@
+#include <stdio.h>
+
+ssize_t getline(char **lineptr, size_t *n, FILE *stream) {
+    return getdelim(lineptr,n,(int)'\n',stream);
+}
diff --git a/libc/stub.h b/libc/stub.h
new file mode 100644
index 0000000..1776eb9
--- /dev/null
+++ b/libc/stub.h
@@ -0,0 +1,13 @@
+#ifndef BIONIC_STUB_H_
+#define BIONIC_STUB_H_
+
+#ifdef BIONIC_STUB_WARNINGS
+#include <stdio.h>
+#include <unistd.h>
+#define BIONICSTUB() \
+	fprintf(stderr,"FIX ME! implement %s()\n", __FUNCTION__)
+#else
+#define BIONICSTUB()
+#endif /* BIONIC_STUB_WARNINGS */
+
+#endif /* BIONIC_STUB_H_ */
diff --git a/libc/termios/tcdrain.c b/libc/termios/tcdrain.c
new file mode 100644
index 0000000..56b8c2b
--- /dev/null
+++ b/libc/termios/tcdrain.c
@@ -0,0 +1,12 @@
+#include <termios.h>
+#include <unistd.h>
+
+int tcdrain(int fd);
+
+/***************************/
+
+#include <sys/ioctl.h>
+
+int tcdrain(int fd) {
+	return ioctl(fd,TCSBRK,1);
+}
diff --git a/libc/unistd/crypt.c b/libc/unistd/crypt.c
new file mode 100644
index 0000000..6db91f8
--- /dev/null
+++ b/libc/unistd/crypt.c
@@ -0,0 +1,442 @@
+#include <unistd.h>
+
+#include <stddef.h> // NULL
+
+char *crypt(const char *key, const char *salt);
+
+/***********/
+
+#include "stub.h"
+
+#include <stdio.h>
+
+/* TODO:
+	   ID  | Method
+	  ---------------------------------------------------------
+	  $1   | MD5
+	  $2a  | Blowfish (not in mainline glibc; added in some
+		   | Linux distributions)
+	  $5   | SHA-256 (since glibc 2.7)
+	  $6   | SHA-512 (since glibc 2.7)
+ */
+
+#include <stdint.h>
+#include <string.h>
+
+#define MD5_SIZE 16
+
+/* MD5 context. */
+typedef struct MD5Context {
+  uint32_t state[4];   /* state (ABCD) */
+  uint32_t count[2];   /* number of bits, modulo 2^64 (lsb first) */
+  unsigned char buffer[64];     /* input buffer */
+} MD5_CTX;
+
+static char *crypt_md5(const char *pw, const char *salt);
+static void MD5Init(MD5_CTX *context);
+static void MD5Update(MD5_CTX *context, const unsigned char *input, unsigned int inputLen);
+static void MD5Final(unsigned char digest[16], MD5_CTX *context);
+static void MD5Transform __P((uint32_t [4], const unsigned char [64]));
+static void _crypt_to64(unsigned char *s, unsigned long v, int n);
+
+static unsigned char PADDING[64] = {
+  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+char *crypt(const char *key, const char *salt) {
+	BIONICSTUB();
+	fprintf(stderr,"still need to implement $2a, $3, $4, and $5 type crypt\n");
+	if (!strncmp(salt, "$1$", 3)) {
+	        salt += 3;
+	        salt = salt + strlen(salt) - strcspn(salt, "$");
+	        return crypt_md5(key, salt);
+	}
+	return crypt_md5(key, salt);
+}
+
+/*
+ * UNIX password
+ */
+
+static char *crypt_md5(const char *pw, const char *salt) {
+        static char     *magic = "$1$"; /*
+                                         * This string is magic for
+                                         * this algorithm.  Having
+                                         * it this way, we can get
+                                         * get better later on
+                                         */
+        static char     passwd[120], *p;
+        static const char *sp,*ep;
+        unsigned char   final[MD5_SIZE];
+        int sl,pl,i;
+        MD5_CTX ctx,ctx1;
+        unsigned long l;
+
+        /* Refine the Salt first */
+        sp = salt;
+
+        /* If it starts with the magic string, then skip that */
+        if(!strncmp(sp,magic,strlen(magic)))
+                sp += strlen(magic);
+
+        /* It stops at the first '$', max 8 chars */
+        for(ep=sp;*ep && *ep != '$' && ep < (sp+8);ep++)
+                continue;
+
+        /* get the length of the true salt */
+        sl = ep - sp;
+
+        MD5Init(&ctx);
+
+        /* The password first, since that is what is most unknown */
+        MD5Update(&ctx,(const unsigned char *)pw,strlen(pw));
+
+        /* Then our magic string */
+        MD5Update(&ctx,(const unsigned char *)magic,strlen(magic));
+
+        /* Then the raw salt */
+        MD5Update(&ctx,(const unsigned char *)sp,sl);
+
+        /* Then just as many characters of the MD5(pw,salt,pw) */
+        MD5Init(&ctx1);
+        MD5Update(&ctx1,(const unsigned char *)pw,strlen(pw));
+        MD5Update(&ctx1,(const unsigned char *)sp,sl);
+        MD5Update(&ctx1,(const unsigned char *)pw,strlen(pw));
+        MD5Final(final,&ctx1);
+        for(pl = strlen(pw); pl > 0; pl -= MD5_SIZE)
+                MD5Update(&ctx,final,pl>MD5_SIZE ? MD5_SIZE : pl);
+
+        /* Don't leave anything around in vm they could use. */
+        memset(final,0,sizeof final);
+
+        /* Then something really weird... */
+        for (i = strlen(pw); i ; i >>= 1)
+                if(i&1)
+                    MD5Update(&ctx, final, 1);
+                else
+                    MD5Update(&ctx,(const unsigned char *)pw, 1);
+
+        /* Now make the output string */
+        strcpy(passwd,magic);
+        strncat(passwd,sp,sl);
+        strcat(passwd,"$");
+
+        MD5Final(final,&ctx);
+
+        /*
+         * and now, just to make sure things don't run too fast
+         * On a 60 Mhz Pentium this takes 34 msec, so you would
+         * need 30 seconds to build a 1000 entry dictionary...
+         */
+        for(i=0;i<1000;i++) {
+                MD5Init(&ctx1);
+                if(i & 1)
+                        MD5Update(&ctx1,(const unsigned char *)pw,strlen(pw));
+                else
+                        MD5Update(&ctx1,final,MD5_SIZE);
+
+                if(i % 3)
+                        MD5Update(&ctx1,(const unsigned char *)sp,sl);
+
+                if(i % 7)
+                        MD5Update(&ctx1,(const unsigned char *)pw,strlen(pw));
+
+                if(i & 1)
+                        MD5Update(&ctx1,(const unsigned char *)final,MD5_SIZE);
+                else
+                        MD5Update(&ctx1,(const unsigned char *)pw,strlen(pw));
+                MD5Final(final,&ctx1);
+        }
+
+        p = passwd + strlen(passwd);
+
+        l = (final[ 0]<<16) | (final[ 6]<<8) | final[12];
+        _crypt_to64((unsigned char *)p,l,4); p += 4;
+        l = (final[ 1]<<16) | (final[ 7]<<8) | final[13];
+        _crypt_to64((unsigned char *)p,l,4); p += 4;
+        l = (final[ 2]<<16) | (final[ 8]<<8) | final[14];
+        _crypt_to64((unsigned char *)p,l,4); p += 4;
+        l = (final[ 3]<<16) | (final[ 9]<<8) | final[15];
+        _crypt_to64((unsigned char *)p,l,4); p += 4;
+        l = (final[ 4]<<16) | (final[10]<<8) | final[ 5];
+        _crypt_to64((unsigned char *)p,l,4); p += 4;
+        l =                    final[11]                ;
+        _crypt_to64((unsigned char *)p,l,2); p += 2;
+        *p = '\0';
+
+        /* Don't leave anything around in vm they could use. */
+        memset(final,0,sizeof final);
+
+        return passwd;
+}
+
+// XXX: Encode and Decode can be aliases to memcpy if i386
+
+/*
+ * Encodes input (uint32_t) into output (unsigned char). Assumes len is
+ * a multiple of 4.
+ */
+
+static void Encode (unsigned char *output, uint32_t *input, unsigned int len) {
+        unsigned int i, j;
+
+        for (i = 0, j = 0; j < len; i++, j += 4) {
+                output[j] = (unsigned char)(input[i] & 0xff);
+                output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
+                output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
+                output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
+        }
+}
+
+/*
+ * Decodes input (unsigned char) into output (uint32_t). Assumes len is
+ * a multiple of 4.
+ */
+
+static void Decode (uint32_t *output, const unsigned char *input, unsigned int len) {
+        unsigned int i, j;
+
+        for (i = 0, j = 0; j < len; i++, j += 4)
+                output[i] = ((uint32_t)input[j]) | (((uint32_t)input[j+1]) << 8) |
+                    (((uint32_t)input[j+2]) << 16) | (((uint32_t)input[j+3]) << 24);
+}
+
+/* F, G, H and I are basic MD5 functions. */
+#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
+#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
+#define H(x, y, z) ((x) ^ (y) ^ (z))
+#define I(x, y, z) ((y) ^ ((x) | (~z)))
+
+/* ROTATE_LEFT rotates x left n bits. */
+#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
+
+/*
+ * FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
+ * Rotation is separate from addition to prevent recomputation.
+ */
+#define FF(a, b, c, d, x, s, ac) { \
+        (a) += F ((b), (c), (d)) + (x) + (uint32_t)(ac); \
+        (a) = ROTATE_LEFT ((a), (s)); \
+        (a) += (b); \
+        }
+#define GG(a, b, c, d, x, s, ac) { \
+        (a) += G ((b), (c), (d)) + (x) + (uint32_t)(ac); \
+        (a) = ROTATE_LEFT ((a), (s)); \
+        (a) += (b); \
+        }
+#define HH(a, b, c, d, x, s, ac) { \
+        (a) += H ((b), (c), (d)) + (x) + (uint32_t)(ac); \
+        (a) = ROTATE_LEFT ((a), (s)); \
+        (a) += (b); \
+        }
+#define II(a, b, c, d, x, s, ac) { \
+        (a) += I ((b), (c), (d)) + (x) + (uint32_t)(ac); \
+        (a) = ROTATE_LEFT ((a), (s)); \
+        (a) += (b); \
+        }
+
+/* MD5 initialization. Begins an MD5 operation, writing a new context. */
+
+static void MD5Init(MD5_CTX *context) {
+
+        context->count[0] = context->count[1] = 0;
+
+        /* Load magic initialization constants.  */
+        context->state[0] = 0x67452301;
+        context->state[1] = 0xefcdab89;
+        context->state[2] = 0x98badcfe;
+        context->state[3] = 0x10325476;
+}
+
+/*
+ * MD5 block update operation. Continues an MD5 message-digest
+ * operation, processing another message block, and updating the
+ * context.
+ */
+
+static void MD5Update(MD5_CTX *context, const unsigned char *input, unsigned int inputLen) {
+        unsigned int i, index, partLen;
+
+        /* Compute number of bytes mod 64 */
+        index = (unsigned int)((context->count[0] >> 3) & 0x3F);
+
+        /* Update number of bits */
+        if ((context->count[0] += ((uint32_t)inputLen << 3))
+            < ((uint32_t)inputLen << 3))
+                context->count[1]++;
+        context->count[1] += ((uint32_t)inputLen >> 29);
+
+        partLen = 64 - index;
+
+        /* Transform as many times as possible. */
+        if (inputLen >= partLen) {
+                memcpy((void *)&context->buffer[index], (const void *)input,
+                    partLen);
+                MD5Transform (context->state, context->buffer);
+
+                for (i = partLen; i + 63 < inputLen; i += 64)
+                        MD5Transform (context->state, (const unsigned char *) &input[i]);
+
+                index = 0;
+        }
+        else
+                i = 0;
+
+        /* Buffer remaining input */
+        memcpy ((void *)&context->buffer[index], (const void *)&input[i],
+            inputLen-i);
+}
+
+/*
+ * MD5 padding. Adds padding followed by original length.
+ */
+
+static void MD5Pad (MD5_CTX *context)
+{
+        unsigned char bits[8];
+        unsigned int index, padLen;
+
+        /* Save number of bits */
+        Encode (bits, context->count, 8);
+
+        /* Pad out to 56 mod 64. */
+        index = (unsigned int)((context->count[0] >> 3) & 0x3f);
+        padLen = (index < 56) ? (56 - index) : (120 - index);
+        MD5Update (context, (const unsigned char *)PADDING, padLen);
+
+        /* Append length (before padding) */
+        MD5Update (context, (const unsigned char *)bits, 8);
+}
+
+/*
+ * MD5 finalization. Ends an MD5 message-digest operation, writing the
+ * the message digest and zeroizing the context.
+ */
+
+static void MD5Final(unsigned char digest[16], MD5_CTX *context)
+{
+        /* Do padding. */
+        MD5Pad (context);
+
+        /* Store state in digest */
+        Encode (digest, context->state, 16);
+
+        /* Zeroize sensitive information. */
+        memset ((void *)context, 0, sizeof (*context));
+}
+
+/* MD5 basic transformation. Transforms state based on block. */
+
+static void MD5Transform (uint32_t state[4], const unsigned char block[64]) {
+        uint32_t a = state[0], b = state[1], c = state[2], d = state[3], x[16];
+
+        Decode (x, block, 64);
+
+        /* Round 1 */
+#define S11 7
+#define S12 12
+#define S13 17
+#define S14 22
+        FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
+        FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
+        FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
+        FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
+        FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
+        FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
+        FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
+        FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
+        FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
+        FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
+        FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
+        FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
+        FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
+        FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
+        FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
+        FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
+
+        /* Round 2 */
+#define S21 5
+#define S22 9
+#define S23 14
+#define S24 20
+        GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
+        GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
+        GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
+        GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
+        GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
+        GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
+        GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
+        GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
+        GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
+        GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
+        GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
+        GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
+        GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
+        GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
+        GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
+        GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
+
+        /* Round 3 */
+#define S31 4
+#define S32 11
+#define S33 16
+#define S34 23
+        HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
+        HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
+        HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
+        HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
+        HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
+        HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
+        HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
+        HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
+        HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
+        HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
+        HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
+        HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
+        HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
+        HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
+        HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
+        HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */
+
+        /* Round 4 */
+#define S41 6
+#define S42 10
+#define S43 15
+#define S44 21
+        II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
+        II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
+        II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
+        II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
+        II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
+        II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
+        II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
+        II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
+        II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
+        II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
+        II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
+        II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
+        II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
+        II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
+        II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
+        II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
+
+        state[0] += a;
+        state[1] += b;
+        state[2] += c;
+        state[3] += d;
+
+        /* Zeroize sensitive information. */
+        memset ((void *)x, 0, sizeof (x));
+}
+
+static unsigned char itoa64[] =         /* 0 ... 63 => ascii - 64 */
+        "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
+
+static void _crypt_to64(unsigned char *s, unsigned long v, int n) {
+        while (--n >= 0) {
+                *s++ = itoa64[v&0x3f];
+                v >>= 6;
+        }
+}
diff --git a/libc/unistd/getlogin.c b/libc/unistd/getlogin.c
new file mode 100644
index 0000000..6186584
--- /dev/null
+++ b/libc/unistd/getlogin.c
@@ -0,0 +1,48 @@
+#include <unistd.h>
+
+char *getlogin(void);
+
+/***************/
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include <pwd.h>
+
+#include "set_errno.h"
+
+char* getlogin(void) {
+	char *n = NULL;
+	int r, fd;
+	struct stat stat;
+	uid_t uid;
+	struct passwd *p;
+
+	/* XXX: Do not use getuid(), because that uid might be different than
+	 * that of the controlling terminal, which might not even exist. */
+
+	r = open("/dev/tty",O_RDONLY);
+	if ( r == -1 )
+		goto out;
+	fd = r;
+
+	r = fstat(fd,&stat);
+	if ( r == -1 )
+		goto closefd;
+
+	uid = stat.st_uid;
+
+	p = getpwuid(uid);
+	if ( !p )
+		goto closefd;
+
+	n = p->pw_name;
+	SET_ERRNO(0);
+
+closefd:
+	close(fd);
+
+out:
+	return n;
+}
diff --git a/libc/unistd/getusershell.c b/libc/unistd/getusershell.c
new file mode 100644
index 0000000..be3b666
--- /dev/null
+++ b/libc/unistd/getusershell.c
@@ -0,0 +1,132 @@
+#include <unistd.h>
+
+char *getusershell(void);
+void setusershell(void);
+void endusershell(void);
+
+/**********************/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <regex.h>
+#ifndef NDEBUG
+#define NDEBUG
+#endif
+#include <assert.h>
+#include <ctype.h>
+
+#include "shell_priv.h"
+#include "set_errno.h"
+#include "branch_prediction.h"
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
+#endif
+
+// empty line or comment line
+static bool eorc(const char *line, const size_t len) {
+	char *o;
+	for(o=(char *)line; (o-line) < len && isblank(*o); o++);
+	return (o-line) == len || *o == '#';
+}
+
+#define LINE_ALLOCATED 256
+static char line[LINE_ALLOCATED];
+
+static FILE *__the_shell = NULL;
+
+static int default_shells_idx = -1;
+static const char *default_shells[] = { "/bin/sh", "/bin/csh" };
+
+char *getusershell(void) {
+	char *r = NULL, *linep;
+	ssize_t line_len;
+	size_t line_alloc;
+	int r2;
+
+	const char *pat = SHELLLINE;
+	static bool expr_initialized = false;
+	static regex_t expr;
+	regmatch_t match[2];
+
+	if ( default_shells_idx >= 0 ) {
+
+		if ( default_shells_idx < ARRAY_SIZE(default_shells) ) {
+			r = (char *) default_shells[default_shells_idx];
+			default_shells_idx++;
+		}
+		goto out;
+
+	}
+
+	if ( !expr_initialized ) {
+		r2 = regcomp(&expr,pat,REG_EXTENDED);
+		assert(!r2);
+		if ( unlikely(r2) ) {
+			WOULD_SET_ERRNO(EINVAL);
+			goto out;
+		}
+	}
+
+	for(;;) {
+
+		linep = line;
+		line_alloc = LINE_ALLOCATED;
+
+		line_len = getline(&linep,&line_alloc,__the_shell);
+		if ( !(linep == line && line_alloc == LINE_ALLOCATED) ) {
+			SET_ERRNO(ENOBUFS);
+			free(linep);
+			goto out;
+		}
+		if ( unlikely(line_len == -1) )
+			goto out;
+
+		if ( eorc(line,line_len) )
+			continue;
+
+		if ( line[line_len -1] == '\n' ) {
+			line[line_len -1] = '\0';
+			line_len--;
+		}
+
+		r2 = regexec(&expr,line,ARRAY_SIZE(match),match,0);
+		if ( unlikely(r2) )
+			continue;
+
+		line[match[1].rm_eo] = '\0';
+		r = &line[match[1].rm_so];
+		break;
+	}
+
+out:
+    return r;
+}
+
+void setusershell(void) {
+	int e = errno;
+	if ( default_shells_idx != -1 ) {
+		default_shells_idx = 0;
+	} else {
+		if ( !__the_shell ) {
+			__the_shell = fopen(_PATH_SHELLS,"r");
+			if ( __the_shell ) {
+				fseek(__the_shell,0,SEEK_SET);
+			} else {
+				default_shells_idx = 0;
+			}
+		} else {
+			default_shells_idx = 0;
+		}
+	}
+	errno = e;
+}
+
+void endusershell(void) {
+	int e = errno;
+	fclose(__the_shell);
+	__the_shell = NULL;
+	default_shells_idx = -1;
+	errno = e;
+}
diff --git a/libc/unistd/shell_priv.h b/libc/unistd/shell_priv.h
new file mode 100644
index 0000000..157be1d
--- /dev/null
+++ b/libc/unistd/shell_priv.h
@@ -0,0 +1,23 @@
+#ifndef SHELL_PRIV_H_
+#define SHELL_PRIV_H_
+
+#define MWS "[ \t]*"
+
+/* FIXME: use NAME_MAX instead of 255, and figure out a way to get a numerical
+ * define to slide into a string define */
+#define PATHELEM "[^/ \t]{1,255}"
+#define ABSPATH "/(" PATHELEM "/)*" PATHELEM
+
+#define SH_SHELL_PAT ABSPATH
+
+#define SHELLLINE \
+	"^" \
+	"(" SH_SHELL_PAT ")" \
+	MWS \
+	"$"
+
+#ifndef _PATH_SHELLS
+#define _PATH_SHELLS "/etc/shells"
+#endif
+
+#endif /* SHELL_PRIV_H_ */
diff --git a/libc/unistd/ttyname.c b/libc/unistd/ttyname.c
new file mode 100644
index 0000000..ba241a0
--- /dev/null
+++ b/libc/unistd/ttyname.c
@@ -0,0 +1,62 @@
+#include <unistd.h>
+
+char *ttyname(int fd);
+
+/***************/
+
+#include <linux/limits.h> // NAME_MAX
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include <pwd.h>
+
+#include <stdio.h>
+
+#include "branch_prediction.h"
+#include "set_errno.h"
+
+// it's unlikely that we'll ever need to switch this to PATH_MAX
+static char ttypathname[NAME_MAX];
+
+#ifndef min
+#define min(a,b) ((a)<=(b) ? (a) : (b))
+#endif
+
+char *ttyname(int fd) {
+	char *n = NULL;
+	int r;
+	pid_t pid;
+	int procfd;
+	ssize_t len;
+
+	if ( !isatty(fd) )
+		goto out;
+
+	pid = getpid();
+
+	// XXX: very linux-specific
+	r = snprintf(ttypathname,sizeof(ttypathname),"/proc/%u/fd/%u",pid,fd);
+	if ( unlikely(r < 0) )
+		goto out;
+
+	procfd = open(ttypathname,O_RDONLY);
+	if ( procfd == -1 )
+		goto out;
+
+	len = readlink(ttypathname,ttypathname,sizeof(ttypathname));
+	if ( unlikely(r == -1) )
+		goto closeprocfd;
+
+	ttypathname[min(sizeof(ttypathname),len)] = '\0';
+
+	n = ttypathname;
+	SET_ERRNO(0);
+
+closeprocfd:
+	close(procfd);
+
+out:
+	return n;
+}
diff --git a/libc/utmp/getutid.c b/libc/utmp/getutid.c
new file mode 100644
index 0000000..67ab38b
--- /dev/null
+++ b/libc/utmp/getutid.c
@@ -0,0 +1,13 @@
+#include <utmp.h>
+
+#include <stddef.h> // NULL
+
+#include "stub.h"
+
+struct utmp __the_utmp = {};
+
+struct utmp *getutid(struct utmp *ut) {
+	struct utmp *utmp = NULL;
+	BIONICSTUB();
+    return utmp;
+}
diff --git a/libc/utmp/getutline.c b/libc/utmp/getutline.c
new file mode 100644
index 0000000..d21f5b3
--- /dev/null
+++ b/libc/utmp/getutline.c
@@ -0,0 +1,10 @@
+#include <utmp.h>
+
+#include <stddef.h> // NULL
+
+#include "stub.h"
+
+struct utmp *getutline(struct utmp *ut) {
+	BIONICSTUB();
+    return NULL;
+}
